//
// Created by tbmc on 25/06/2017.
//

#include "key.h"
#include "common_aes.h"



/*
const uint32_t RCON_ARRAY[] = {
    0x01000000, 0x02000000, 0x04000000, 0x08000000,
    0x10000000, 0x20000000, 0x40000000, 0x80000000,
    0x1B000000, 0x36000000, 0x6C000000, 0xD8000000,
    0xAB000000, 0x4D000000, 0x9A000000,
};
*/

const uint8_t RCON_VALUES[] = {
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d,
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab,
    0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,
    0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25,
    0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01,
    0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,
    0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa,
    0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a,
    0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,
    0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,
    0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,
    0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33,
    0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb,
};

void key_rot_word(uint8_t *row)
{
    shift_row(row, 1);
}

void key_sub_word(uint8_t *row)
{
    int i;
    for(i = 0; i < NUMBER_ROWS; i++)
        row[i] = sub_byte(row[i]);
}

/*
uint32_t rcon(int round, enum KeySize key_size)
{
    int r = (round / (key_size / 4)) - 1;
    return RCON_VALUES[r];
}
*/
uint8_t rcon(uint8_t num)
{
    return RCON_VALUES[num];
}

void key_core_expansion(uint8_t *word, int iteration)
{
    key_rot_word(word);

    key_sub_word(word);

    word[0] = word[0] ^ rcon(iteration);
}

int key_get_expanded_key_size(int Nr)
{
    return 16 * (Nr + 1);
}

void key_expand_key(uint8_t *expanded_key, uint8_t *key, enum KeySize key_size, int expanded_key_size)
{
    int i, current_size = 0, rcon_iteration = 1;
    uint8_t t[4] = { 0, 0, 0, 0 };

    // memcpy(expanded_key, key, key_size);
    /* Set the 16,24,32 bytes of the expanded key to the input key */
    for(i = 0; i < key_size; i++)
        expanded_key[i] = key[i];
    current_size += key_size;

    while(current_size < expanded_key_size)
    {
        /* Get last 4 bytes in temporary array */
        for(i = 0; i < 4; i++)
            t[i] = expanded_key[(current_size - 4) + i];

        /*
         * Every 16,24,32 bytes, we apply the core schedule to t
         * and increment rcon_iteration afterwards
         */
        if(current_size % key_size == 0)
            key_core_expansion(t, rcon_iteration++);

        /* For 256-bit keys, we add extra sbox to the calculation */
        if(key_size == SIZE_32 && (current_size % key_size == 16))
            key_sub_word(t);

        for(i = 0; i < 4; i++)
        {
            expanded_key[current_size] = expanded_key[current_size - key_size] ^ t[i];
            current_size++;
        }
    }
}





